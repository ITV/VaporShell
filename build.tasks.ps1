Param(
    [Parameter(Mandatory, Position = 0)]
    [String]
    $ModuleName,
    [Parameter()]
    [String]
    $NextModuleVersion,
    [Parameter()]
    [String]
    $GalleryVersion,
    [Parameter()]
    [String]
    $ManifestVersion,
    [Parameter()]
    [String]
    $PrereleaseString,
    [Parameter()]
    [String]
    $SourceModuleDirectory,
    [Parameter()]
    [String]
    $SourceAdditionalModuleDirectory,
    [Parameter()]
    [String]
    $SourceManifestPath,
    [Parameter()]
    [String]
    $TargetDirectory,
    [Parameter()]
    [String]
    $TargetManifestPath,
    [Parameter()]
    [String]
    $TargetPSM1Path,
    [Parameter()]
    [String]
    $TargetModuleDirectory,
    [Parameter()]
    [String]
    $TargetVersionDirectory,
    [Parameter()]
    [Switch]
    $NoUpdate,
    [Parameter()]
    [Switch]
    $CoreOnly,
    [parameter()]
    [string[]]
    $Tag
)

# Synopsis: Default task
Task . Init, Clean, Build, Import, PackageBuildOutputAsArtifact, BuildReleaseZips, CleanBuildOutput

# Synopsis: Builds everything
Task Build  Init, Update, BuildCore, BuildSubmodules, BuildDotnet

# Synopsis: Cleans and builds just the classes
Task BuildClasses BuildCoreClasses, BuildSubmodules

# Synopsis: Builds only the core components and submodules, excluding Resource Types and Resource Property Types
Task BuildCore Init, BuildCoreOnly, BuildDotnet, ImportCore

# Synopsis: Autogenerates the service-specific modules and imports them once done to confirm validity.
Task BuildNonCore Init, BuildSubmodules, ImportSubmodules

# Synopsis: Run Pester tests for classes only (no Clean/Compile)
Task TestClasses Init, { $script:TestPath = [System.IO.Path]::Combine($BuildRoot,"Tests","Class Tests") }, Test

# Synopsis: Run all core tasks
Task Full ., Test

# Synopsis: Cleans only compiled core module
Task CleanCore Init, {
    remove 'BuildOutput/VaporShell'
    remove 'BuildOutput/BuildOutputCompressed.zip'
}

# Synopsis: Cleans all non-core / autogenerated modules
Task CleanNonCore Init, CleanNonCoreFunctions, CleanSubmodules

# Synopsis: Cleans everything
Task Clean Init, {
    remove 'BuildOutput'
}

Task Init {
    Import-Module Configuration
    Import-Module $([System.IO.Path]::Combine($BuildRoot,'ci','VaporShell.CI.Tools')) -Force
    $Script:SourceModuleDirectory = [System.IO.Path]::Combine($BuildRoot, $ModuleName)
    $Script:GalleryVersion = (Get-PSGalleryVersion $ModuleName).Version
    $Script:SourceManifestPath = Join-Path $SourceModuleDirectory "$($ModuleName).psd1"
    switch -RegEx ($env:BHBranchName) {
        '^(master|main)$' {
            $Script:PrereleaseString = $null
            $summaryNextVersionSuffix = $null
        }
        '^(beta|rc|nightly|alpha)$' {
            $Script:PrereleaseString = "$($env:BHBranchName)".ToLower() + (Get-Date).ToString('yyyyMMddHHmm')
            $summaryNextVersionSuffix = "-" + $Script:PrereleaseString
        }
        default {
            $Script:PrereleaseString = 'local' + (Get-Date).ToString('yyyyMMddHHmm')
            $summaryNextVersionSuffix = "-" + $Script:PrereleaseString
        }
    }
    $Script:ManifestVersion = ((Import-Metadata -Path $SourceManifestPath).ModuleVersion.Split('.')[0..1] + '0') -join '.'
    $Script:NextModuleVersion = Get-NextModuleVersion -GalleryVersion $GalleryVersion -ManifestVersion $ManifestVersion -IsPrerelease:$($null -ne $Script:PrereleaseString)
    $Script:TargetDirectory = [System.IO.Path]::Combine($BuildRoot, 'BuildOutput')
    $Script:TargetModuleDirectory = [System.IO.Path]::Combine($TargetDirectory, $ModuleName)
    $Script:SourceAdditionalModuleDirectory = [System.IO.Path]::Combine($TargetDirectory, '_autoGenerated')
    $Script:TargetVersionDirectory = [System.IO.Path]::Combine($TargetModuleDirectory, $NextModuleVersion)
    $Script:TargetManifestPath = [System.IO.Path]::Combine($TargetVersionDirectory, "$($ModuleName).psd1")
    $Script:TargetPSM1Path = [System.IO.Path]::Combine($TargetVersionDirectory, "$($ModuleName).psm1")
    Write-BuildLog "Build System Details:"
    @(
        ""
        "~~~~~~~ Summary ~~~~~~~"
        "In CI?                 : $($IsCI -or (Test-Path Env:\TF_BUILD))"
        "Project                : $ModuleName"
        "Manifest Version       : $ManifestVersion"
        "Gallery Version        : $GalleryVersion"
        "Next Module Version    : $NextModuleVersion$($summaryNextVersionSuffix)"
        "Engine                 : PowerShell $($PSVersionTable.PSVersion.ToString())"
        "Host OS                : $(if($PSVersionTable.PSVersion.Major -le 5 -or $IsWindows){"Windows"}elseif($IsLinux){"Linux"}elseif($IsMacOS){"macOS"}else{"[UNKNOWN]"})"
        "PWD                    : $PWD"
        ""
        "~~~~~ Directories ~~~~~"
        "SourceModuleDirectory  : $SourceModuleDirectory"
        "TargetDirectory        : $TargetDirectory"
        "TargetModuleDirectory  : $TargetModuleDirectory"
        "TargetVersionDirectory : $TargetVersionDirectory"
        "TargetManifestPath     : $TargetManifestPath"
        "TargetPSM1Path         : $TargetPSM1Path"
        ""
        "~~~~~ Environment ~~~~~"
    ) | Write-BuildLog
    Write-BuildLog "$((Get-ChildItem Env: | Where-Object {$_.Name -match "^(BUILD_|BH)"} | Sort-Object Name | Format-Table Name,Value -AutoSize | Out-String).Trim())"
    if (-not (Test-Path $TargetDirectory)) {
        New-Item $TargetDirectory -ItemType Directory -Force
    }
}

Task CleanNonCoreFunctions Init, {
    if (Test-Path $script:SourceAdditionalModuleDirectory) {
        Get-ChildItem $script:SourceAdditionalModuleDirectory -Directory | ForEach-Object {
            $publicPath = [System.IO.Path]::Combine($_.FullName,'Public')
            $classPath = [System.IO.Path]::Combine($_.FullName,'Classes')
            $publicPath,$classPath | ForEach-Object {
                Get-ChildItem $_ -Directory | ForEach-Object {
                    remove $_.FullName
                }
            }dep
        }
    }
    else {
        $null = New-Item -ItemType Directory $script:SourceAdditionalModuleDirectory -Force
    }
}

Task CleanSubmodules Init, {
    Get-ChildItem 'BuildOutput' -Directory | Where-Object {$_.Name -ne $ModuleName} | ForEach-Object {
        remove $_.FullName
    }
}

# Synopsis: Autogenerates module functions and classes before compilation
Task Update -If { -not $NoUpdate -and -not $CoreOnly } Init, CleanNonCore, {
    git submodule update --recursive
    Import-Module ([System.IO.Path]::Combine($BuildRoot,'ci','VaporShell.CI.Tools')) -Verbose
    Write-BuildLog 'Updating Resource and Property Type functions with current AWS spec sheet...'
    Update-VSResourceFunctions -ModuleVersion $NextModuleVersion
}

# Synopsis: Compile the submodules
Task BuildSubmodules Init, CleanSubmodules, {
    $submodulesToBuild = Get-ChildItem $SourceAdditionalModuleDirectory -Directory | Select-Object -ExpandProperty BaseName
    foreach ($sub in $SubmodulesToBuild) {
        $subSourceModuleDirectory = [System.IO.Path]::Combine($SourceAdditionalModuleDirectory, $sub)
        $subSourceManifestPath = Join-Path $subSourceModuleDirectory "$($sub).psd1"
        $subSourcePSM1Path = Join-Path $subSourceModuleDirectory "$($sub).psm1"
        $subTargetModuleDirectory = [System.IO.Path]::Combine($TargetDirectory, $sub)
        $subTargetVersionDirectory = [System.IO.Path]::Combine($subTargetModuleDirectory, $NextModuleVersion)
        $subTargetManifestPath = [System.IO.Path]::Combine($subTargetVersionDirectory, "$($sub).psd1")
        $subTargetPSM1Path = [System.IO.Path]::Combine($subTargetVersionDirectory, "$($sub).psm1")
        $functionsToExport = @()
        $aliasesToExport = @()
        if (-not (Test-Path $subTargetVersionDirectory)) {
            Write-BuildLog "[$sub] Creating target folder for module"
            New-Item -Path $subTargetVersionDirectory -ItemType Directory -Force
        }
        Write-BuildLog "[$sub] Copying source PSM1 to target folder for module"
        $psm1 = Copy-Item -Path $subSourcePSM1Path -Destination $subTargetVersionDirectory -PassThru -Force

        Write-BuildLog "[$sub] Bumping source manifest version from '$ManifestVersion' to '$NextModuleVersion' to prevent errors"
        Update-Metadata -Path $subSourceManifestPath -PropertyName ModuleVersion -Value $NextModuleVersion

        $sourceMetadata = Import-Metadata -Path $subSourceManifestPath
        if ($sourceMetadata.RequiredModules.GetEnumerator().Where({$_.ModuleName -eq 'VaporShell'}).ModuleVersion -ne $ManifestVersion) {
            Write-BuildLog "[$sub] Setting source manifest RequiredModules to VaporShell@$ManifestVersion"
            Update-Metadata -Path $subSourceManifestPath -PropertyName RequiredModules -Value @('VaporShell')
            #Update-Metadata -Path $subSourceManifestPath -PropertyName RequiredModules -Value @([ordered]@{ModuleName = 'VaporShell';ModuleVersion = $ManifestVersion})
        }

        Write-BuildLog "[$sub] Copying content from source manifest to target manifest"
        $cleanContents = Invoke-Formatter (([System.IO.File]::ReadAllLines($subSourceManifestPath).Where({-not [string]::IsNullOrWhiteSpace($_.Trim())})).Trim() -join [System.Environment]::NewLine)
        $cleanContents | Set-Content $subSourceManifestPath -Force

        # Copy over manifest
        Write-BuildLog "[$sub] Copying source manifest to target folder"
        Copy-Item -Path $subSourceManifestPath -Destination $subTargetVersionDirectory

        $updatedScriptsToProcess = @()
        $psm1UsingStatements = @()
        $attributesUsingStatements = @()
        $classesUsingStatements = @()
        foreach ($scope in @('Attributes', 'Classes', 'Private', 'Public')) {
            $gciPath = [System.IO.Path]::Combine($subSourceModuleDirectory, $scope)
            if (Test-Path $gciPath) {
                $toProcess = Get-ChildItem -Path $gciPath -Filter "*.ps1" -Recurse -File | Where-Object {$_.FullName -notlike "*Development Tools*"} | Sort-Object FullName
                if ($toProcess) {
                    $target = if ($scope -match '^(Attributes|Classes)$') {
                        New-Item -Path ([System.IO.Path]::Combine($subTargetVersionDirectory, "$sub.$scope.ps1")) -ItemType File -Force
                        $updatedScriptsToProcess += "$sub.$scope.ps1"
                    }
                    else {
                        $psm1
                    }
                    if ($scope -match '^(Attributes|Classes)$') {
                        "[CmdletBinding()]`nParam()`n" | Add-Content -Path $target -Encoding UTF8
                    }
                    Write-BuildLog "[$sub] Copying contents from files in source folder '$($scope)' to $($target.Name)"
                    $toProcess | ForEach-Object {
                        Write-BuildLog "[$sub] Working on: $($_.FullName.Replace("$gciPath$([System.IO.Path]::DirectorySeparatorChar)",''))"
                        $content = Get-Content $_.FullName
                        if ($usingStatements = $content | Where-Object { $_ -match '^\s*using\s+(module|namespace|assembly)\s+\w+.*$' }) {
                            switch ($scope) {
                                Attributes {
                                    $attributesUsingStatements += $usingStatements
                                }
                                Classes {
                                    $classesUsingStatements += $usingStatements
                                }
                                default {
                                    $psm1UsingStatements += $usingStatements
                                }
                            }
                        }
                        $nonUsingStatements = ($content | Where-Object { $_ -notmatch '^\s*using\s+(module|namespace|assembly)\s+\w+.*$' }) -join "`n"
                        if ($scope -match '^(Attributes|Classes)$') {
                            "Write-Verbose `"Importing class '$($_.BaseName -replace '^(\d+\s+-\s+){0,1}')'`"" | Add-Content -Path $target -Encoding UTF8
                        }
                        "$nonUsingStatements`n" | Add-Content -Path $target -Encoding UTF8
                        if ($scope -eq 'Public') {
                            $functionsToExport += $_.BaseName
                            "Export-ModuleMember -Function '$($_.BaseName)'`n" | Add-Content -Path $target -Encoding UTF8
                        }
                    }
                }
            }
        }
        switch ($true) {
            { $psm1UsingStatements.Count -ge 1 } {
                Write-BuildLog "Adding using statements to PSM1"
                $path = $psm1.FullName
                $cleanContents = (($psm1UsingStatements | ForEach-Object { $_.Trim() }) | Sort-Object -Unique) -join "`n"
                if (-not (Test-Path $path)) {
                    New-Item -Path $path -ItemType File
                }
                $currentContents = Get-Content $path -Raw
                $newContents = @($cleanContents, $currentContents)
                ($newContents -join "`n") | Set-Content $path -Encoding UTF8 -Force
            }
            { $attributesUsingStatements.Count -ge 1 } {
                Write-BuildLog "[$sub] Adding using statements to $($sub).Attributes.ps1"
                $path = [System.IO.Path]::Combine($subTargetVersionDirectory, "$($sub).Attributes.ps1")
                $cleanContents = (($attributesUsingStatements | ForEach-Object { $_.Trim() }) | Sort-Object -Unique) -join "`n"
                $currentContents = Get-Content $path -Raw
                $newContents = @($cleanContents, $currentContents)
                ($newContents -join "`n") | Set-Content $path -Encoding UTF8 -Force
            }
            { $classesUsingStatements.Count -ge 1 } {
                Write-BuildLog "[$sub] Adding using statements to $($sub).Classes.ps1"
                $path = [System.IO.Path]::Combine($subTargetVersionDirectory, "$($sub).Classes.ps1")
                $cleanContents = (($classesUsingStatements | ForEach-Object { $_.Trim() }) | Sort-Object -Unique) -join "`n"
                if (-not (Test-Path $path)) {
                    $null = New-Item -Path $path -ItemType File
                }
                $currentContents = Get-Content $path -Raw
                $newContents = @($cleanContents, $currentContents)
                ($newContents -join "`n") | Set-Content $path -Encoding UTF8 -Force
            }
        }
        if ($updatedScriptsToProcess.Count) {
            Update-Metadata -Path $subTargetManifestPath -PropertyName ScriptsToProcess -Value $updatedScriptsToProcess
        }

        $currentMetadata = Import-Metadata -Path $subTargetManifestPath
        if ($null -ne $Script:PrereleaseString) {
            Write-BuildLog "[$sub] Setting Prerelease string to '$($Script:PrereleaseString)' for branch '$env:BHBranchName'"
            $currentMetadata['PrivateData']['PSData']['Prerelease'] = $Script:PrereleaseString
            $currentMetadata | Export-Metadata -Path $subTargetManifestPath
        }
        elseif ($currentMetadata['PrivateData']['PSData'].ContainsKey('Prerelease')) {
            Write-BuildLog "[$sub] Removing Prerelease string from module manifest for branch '$env:BHBranchName'"
            $currentMetadata['PrivateData']['PSData'].Remove('Prerelease')
            $currentMetadata | Export-Metadata -Path $subTargetManifestPath
        }

        Get-ChildItem -Path $subSourceModuleDirectory -Directory | Where-Object { $_.BaseName -notin @('Attributes','Classes', 'Private', 'Public') } | ForEach-Object {
            Write-BuildLog "[$sub] Copying source folder to target: $($_.BaseName)"
            Copy-Item $_.FullName -Destination $subTargetVersionDirectory -Container -Recurse
        }

        # Update FunctionsToExport and AliasesToExport on manifest
        $params = @{
            Path = $subTargetManifestPath
        }
        if ($functionsToExport.Count) {
            Update-Metadata @params -PropertyName FunctionsToExport -Value ($functionsToExport | Sort-Object)
        }
        if ($aliasesToExport.Count) {
            Update-Metadata @params -PropertyName AliasesToExport -Value ($aliasesToExport | Sort-Object)
        }

        Write-BuildLog "[$sub] Updating target manifest file with exports"

        Write-BuildLog "[$sub] Reverting bumped source manifest version from '$NextModuleVersion' to '$ManifestVersion'"
        Update-Metadata -Path $subSourceManifestPath -PropertyName ModuleVersion -Value $ManifestVersion
        ([System.IO.File]::ReadAllText($subSourceManifestPath)).Trim() | Set-Content $subSourceManifestPath

        Write-BuildLog "[$sub] Created compiled module at [$subTargetVersionDirectory]!"
        Write-BuildLog "[$sub] Output version directory contents:"
        Get-ChildItem $subTargetVersionDirectory | Format-Table -AutoSize
    }
}

# Synopsis: Compile the dotnet dll
Task BuildDotnet -If {$false} Init, {
    # This is commented out for now, possible deprecation due to conversion to PS classes
    Write-BuildLog 'Compiling VaporShell.Core.dll'
    dotnet build .\VaporShell.Core\
    Get-Item ".\VaporShell.Core\obj\Debug\netstandard2.0\VaporShell.Core.dll" | Copy-Item -Destination $TargetVersionDirectory -Recurse -ErrorAction SilentlyContinue -Force
}

# Synopsis: Compiles module from source
Task BuildCoreOnly CleanCore, {
    $functionsToExport = @()
    $aliasesToExport = @()
    Write-BuildLog 'Creating psm1...'
    $psm1 = New-Item -Path $TargetPSM1Path -ItemType File -Force

    $psm1Header = @(
        '[CmdletBinding()]'
        'Param ()'
        '$VaporshellPath = $PSScriptRoot'
        #'if ($null -eq ([System.AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {$_.Location #-match "VaporShell.Core.dll"})) {'
        #'    Add-Type -Path "$VaporshellPath\VaporShell.Core.dll" -ReferencedAssemblies ([PowerShell].#Assembly.Location)'
        #'}'
    ) -join "`n"
    $psm1Header | Add-Content -Path $psm1 -Encoding UTF8

    if ($ManifestVersion -ne $NextModuleVersion) {
        Write-BuildLog "Bumping source manifest version from '$ManifestVersion' to '$NextModuleVersion' to prevent errors"
        Update-Metadata -Path $SourceManifestPath -PropertyName ModuleVersion -Value $NextModuleVersion
        ([System.IO.File]::ReadAllText($SourceManifestPath)).Trim() | Set-Content $SourceManifestPath
    }

    # Copy over manifest
    Write-BuildLog "[$ModuleName] Copying source manifest to target folder"
    Copy-Item -Path $SourceManifestPath -Destination $TargetVersionDirectory

    $updatedScriptsToProcess = @()
    $psm1UsingStatements = @()
    $attributesUsingStatements = @()
    $classesUsingStatements = @()

    Write-BuildLog "[$ModuleName] Generating VaporShellModule enum from latest service module list in BuildOutput"
    $vsModulesNames = (Get-ChildItem $Script:TargetDirectory -Filter 'VaporShell*').BaseName
    $vsModuleEnum = @('enum VaporShellModule {')
    foreach ($vsMod in $vsModulesNames) {
        $vsModuleEnum += "    $($vsMod -replace '^VaporShell\.')"
    }
    $vsModuleEnum += '}'
    $vsModuleEnum -join ([Environment]::NewLine) | Set-Content ([System.IO.Path]::Combine($BuildRoot, 'VaporShell', 'Classes', '00 - Enums', 'VaporShellModule.ps1')) -Force
    foreach ($scope in @('Attributes', 'Classes', 'Private', 'Public')) {
        $gciPath = [System.IO.Path]::Combine($SourceModuleDirectory, $scope)
        if (Test-Path $gciPath) {
            $toProcess = Get-ChildItem -Path $gciPath -Filter "*.ps1" -Recurse -File | Where-Object {$_.FullName -notlike "*Development Tools*"} | Sort-Object FullName
            if ($toProcess) {
                $target = if ($scope -match '^(Attributes|Classes)$') {
                    New-Item -Path ([System.IO.Path]::Combine($TargetVersionDirectory, "$($ModuleName).$scope.ps1")) -ItemType File -Force
                    $updatedScriptsToProcess += "$($ModuleName).$scope.ps1"
                }
                else {
                    $psm1
                }
                if ($scope -match '^(Attributes|Classes)$') {
                    "[CmdletBinding()]`nParam()`n" | Add-Content -Path $target -Encoding UTF8
                }
                Write-BuildLog "[$ModuleName] Copying contents from files in source folder '$($scope)' to $($target.Name)"
                $toProcess | ForEach-Object {
                    Write-BuildLog "[$ModuleName] [$ModuleName] Working on: $($_.FullName.Replace("$gciPath$([System.IO.Path]::DirectorySeparatorChar)",''))"
                    $content = Get-Content $_.FullName
                    if ($usingStatements = $content | Where-Object { $_ -match '^\s*using\s+(module|namespace|assembly)\s+\w+.*$' }) {
                        switch ($scope) {
                            Attributes {
                                $attributesUsingStatements += $usingStatements
                            }
                            Classes {
                                $classesUsingStatements += $usingStatements
                            }
                            default {
                                $psm1UsingStatements += $usingStatements
                            }
                        }
                    }
                    $nonUsingStatements = ($content | Where-Object { $_ -notmatch '^\s*using\s+(module|namespace|assembly)\s+\w+.*$' }) -join "`n"
                    if ($scope -match '^(Attributes|Classes)$') {
                        "Write-Verbose `"Importing class '$($_.BaseName -replace '^(\d+\s+-\s+){0,1}')'`"" | Add-Content -Path $target -Encoding UTF8
                    }
                    "$nonUsingStatements`n" | Add-Content -Path $target -Encoding UTF8
                    if ($scope -eq 'Public') {
                        $functionsToExport += $_.BaseName
                        "Export-ModuleMember -Function '$($_.BaseName)'`n" | Add-Content -Path $target -Encoding UTF8
                    }
                }
            }
        }
    }
    switch ($true) {
        { $psm1UsingStatements.Count -ge 1 } {
            Write-BuildLog "[$ModuleName] Adding using statements to PSM1"
            $path = $psm1.FullName
            $cleanContents = (($psm1UsingStatements | ForEach-Object { $_.Trim() }) | Sort-Object -Unique) -join "`n"
            if (-not (Test-Path $path)) {
                New-Item -Path $path -ItemType File
            }
            $currentContents = Get-Content $path -Raw
            $newContents = @($cleanContents, $currentContents)
            ($newContents -join "`n") | Set-Content $path -Encoding UTF8 -Force
        }
        { $attributesUsingStatements.Count -ge 1 } {
            Write-BuildLog "[$ModuleName] Adding using statements to $($ModuleName).Attributes.ps1"
            $path = [System.IO.Path]::Combine($TargetVersionDirectory, "$($ModuleName).Attributes.ps1")
            $cleanContents = (($attributesUsingStatements | ForEach-Object { $_.Trim() }) | Sort-Object -Unique) -join "`n"
            if (-not (Test-Path $path)) {
                New-Item -Path $path -ItemType File
            }
            $currentContents = Get-Content $path -Raw
            $newContents = @($cleanContents, $currentContents)
            ($newContents -join "`n") | Set-Content $path -Encoding UTF8 -Force
        }
        { $classesUsingStatements.Count -ge 1 } {
            Write-BuildLog "[$ModuleName] Adding using statements to $($ModuleName).Classes.ps1"
            $path = [System.IO.Path]::Combine($TargetVersionDirectory, "$($ModuleName).Classes.ps1")
            $cleanContents = (($classesUsingStatements | ForEach-Object { $_.Trim() }) | Sort-Object -Unique) -join "`n"
            if (-not (Test-Path $path)) {
                New-Item -Path $path -ItemType File
            }
            $currentContents = Get-Content $path -Raw
            $newContents = @($cleanContents, $currentContents)
            ($newContents -join "`n") | Set-Content $path -Encoding UTF8 -Force
        }
    }
    if ($updatedScriptsToProcess.Count) {
        Update-Metadata -Path $TargetManifestPath -PropertyName ScriptsToProcess -Value $updatedScriptsToProcess
    }

    $currentMetadata = Import-Metadata -Path $TargetManifestPath
    if ($null -ne $Script:PrereleaseString) {
        Write-BuildLog "[$ModuleName] Setting Prerelease string to '$($Script:PrereleaseString)' for branch '$env:BHBranchName'"
        $currentMetadata['PrivateData']['PSData']['Prerelease'] = $Script:PrereleaseString
        $currentMetadata | Export-Metadata -Path $TargetManifestPath
    }
    elseif ($currentMetadata['PrivateData']['PSData'].ContainsKey('Prerelease')) {
        Write-BuildLog "[$ModuleName] Removing Prerelease string from module manifest for branch '$env:BHBranchName'"
        $currentMetadata['PrivateData']['PSData'].Remove('Prerelease')
        $currentMetadata | Export-Metadata -Path $TargetManifestPath
    }

    Get-ChildItem -Path $SourceModuleDirectory -Directory | Where-Object { $_.BaseName -notin @('Attributes','Classes', 'Private', 'Public') } | ForEach-Object {
        Write-BuildLog "[$ModuleName] Copying source folder to target: $($_.BaseName)"
        Copy-Item $_.FullName -Destination $TargetVersionDirectory -Container -Recurse
    }

    Write-BuildLog 'Copying latest AWSSDK assembly dependencies to output path'
    Save-Module 'AWS.Tools.CloudFormation', 'AWS.Tools.S3' -Path $BuildRoot -Repository PSGallery -Force
    Get-Item 'AWS.Tools.*' | ForEach-Object {
        Get-ChildItem $_.FullName -Recurse -Filter 'AWSSDK.*.dll' | Copy-Item -Destination $TargetVersionDirectory -Recurse -ErrorAction SilentlyContinue
        Remove-Item $_.FullName -Recurse -Force
    }

    #Write-BuildLog 'Copying DSL module'
    #Copy-Item -Path "$SourceModuleDirectory\VaporShell.DSL.psm1" -Destination "$TargetVersionDirectory" -Recurse -ErrorAction SilentlyContinue

    Write-BuildLog 'Creating Variable hash'
    $varHash = @("@{")
    Get-Content -Path "$SourceModuleDirectory\Private\PseudoParams.txt" | ForEach-Object {
        $name = "_$(($_ -replace "::").Trim())"
        $varHash += "    '$name' = '$($_.Trim())'"
    }
    $varHash += "}"

    Write-BuildLog 'Creating Alias hash'
    $aliasHash = @("@{")
    Get-ChildItem "$SourceModuleDirectory\Public\Intrinsic Functions" | ForEach-Object {
        $name = $_.BaseName -replace '^Add-'
        $aliasesToExport += $name
        $aliasHash += "    '$name' = '$($_.BaseName.Trim())'"
        $name = $_.BaseName -replace '^Add-Fn','!'
        $aliasesToExport += $name
        $aliasHash += "    '$name' = '$($_.BaseName.Trim())'"
    }
    Get-ChildItem "$SourceModuleDirectory\Public\Condition Functions" | ForEach-Object {
        $name = $_.BaseName -replace '^Add-'
        $aliasesToExport += $name
        $aliasHash += "    '$name' = '$($_.BaseName.Trim())'"
        $name = if ($_.BaseName -eq 'Add-ConRef') {
            '!Condition'
        }
        else {
            $_.BaseName -replace '^Add-Con', '!'
        }
        $aliasesToExport += $name
        $aliasHash += "    '$name' = '$($_.BaseName.Trim())'"
    }
    $name = '!Include'
    $aliasesToExport += $name
    $aliasHash += "    '$name' = 'Add-Include'"
    $aliasHash += "}"

    Write-BuildLog 'Setting remainder of PSM1 contents'
    $hashDefinitions = @(
        '$aliases = @()'
        "`$aliasHash = $($aliasHash -join "`n")"
        '$aliasHash.GetEnumerator() | ForEach-Object {'
        '    New-Alias -Name $_.Key -Value $_.Value -Force'
        '    $aliases += $_.Key'
        '}'
        ''
        '$vars = @()'
        "`$varHash = $($varHash -join "`n")"
        '$varHash.GetEnumerator() | ForEach-Object {'
        '    New-Variable -Name $_.Key -Value $_.Value -Force'
        '    $vars += $_.Key'
        '}'
        ''
        #'$DSLModulePath = (Resolve-Path "$PSScriptRoot\VaporShell.DSL.psm1").Path'
        #'Import-Module $DSLModulePath -DisableNameChecking -Force -Scope Global'
        #''
        'Export-ModuleMember -Variable $vars -Alias $aliases'
        ''
        '$global:VSError = [System.Collections.Generic.List[VSError]]::new()'
    ) -join "`n"
    $hashDefinitions | Add-Content -Path $psm1 -Encoding UTF8

    $aliases = @()
    Get-ChildItem "$SourceModuleDirectory\Public\Intrinsic Functions" | ForEach-Object {
        $aliases += ($_.BaseName).Replace('Add-', '')
    }
    Get-ChildItem "$SourceModuleDirectory\Public\Condition Functions" | ForEach-Object {
        $aliases += ($_.BaseName).Replace('Add-', '')
    }
    $vars = @()
    Get-Content -Path "$SourceModuleDirectory\Private\PseudoParams.txt" | ForEach-Object {
        $vars += "_$(($_ -replace "::").Trim())"
    }

    # Update FunctionsToExport and AliasesToExport on manifest
    $params = @{
        Path              = $TargetManifestPath
        FunctionsToExport = ($functionsToExport | Sort-Object)
        VariablesToExport = $vars
        AliasesToExport   = ($aliasesToExport | Sort-Object)
    }

    Write-BuildLog "[$ModuleName] Updating target manifest file with exports"
    Update-ModuleManifest @params

    if ($ManifestVersion -ne $NextModuleVersion) {
        Write-BuildLog "[$ModuleName] Reverting bumped source manifest version from '$NextModuleVersion' to '$ManifestVersion'"
        Update-Metadata -Path $SourceManifestPath -PropertyName ModuleVersion -Value $ManifestVersion
        ([System.IO.File]::ReadAllText($SourceManifestPath)).Trim() | Set-Content $SourceManifestPath
    }
    Write-BuildLog "[$ModuleName] Created compiled module at [$TargetVersionDirectory]!"
    Write-BuildLog 'Output version directory contents:'
    Get-ChildItem $TargetVersionDirectory | Format-Table -AutoSize
}

Task BuildCoreClasses Init, {
    $updatedScriptsToProcess = @()
    $attributesUsingStatements = @()
    $classesUsingStatements = @()
    foreach ($scope in @('Attributes', 'Classes')) {
        $gciPath = [System.IO.Path]::Combine($SourceModuleDirectory, $scope)
        if (Test-Path $gciPath) {

            $target = New-Item -Path ([System.IO.Path]::Combine($TargetVersionDirectory, "$($ModuleName).$scope.ps1")) -ItemType File -Force
            $updatedScriptsToProcess += "$($ModuleName).$scope.ps1"

            Write-BuildLog "[$ModuleName] Copying contents from files in source folder '$($scope)' to $($target.Name)"
            Get-ChildItem -Path $gciPath -Filter "*.ps1" -Recurse -File | Sort-Object FullName | ForEach-Object {
                Write-BuildLog "[$ModuleName] Working on: $($_.FullName.Replace("$gciPath$([System.IO.Path]::DirectorySeparatorChar)",''))"
                $content = Get-Content $_.FullName
                if ($usingStatements = $content | Where-Object { $_ -match '^\s*using\s+(module|namespace|assembly)\s+\w+.*$' }) {
                    switch ($scope) {
                        Attributes {
                            $attributesUsingStatements += $usingStatements
                        }
                        Classes {
                            $classesUsingStatements += $usingStatements
                        }
                    }
                }
                $nonUsingStatements = ($content | Where-Object { $_ -notmatch '^\s*using\s+(module|namespace|assembly)\s+\w+.*$' }) -join "`n"
                "Write-Verbose `"Importing class '$($_.BaseName -replace '^(\d+\s+-\s+){0,1}')'`"" | Add-Content -Path $target -Encoding UTF8
                "$nonUsingStatements`n" | Add-Content -Path $target -Encoding UTF8
            }
        }
    }
    switch ($true) {
        { $attributesUsingStatements.Count -ge 1 } {
            Write-BuildLog "[$ModuleName] Adding using statements to $($ModuleName).Attributes.ps1"
            $path = [System.IO.Path]::Combine($TargetVersionDirectory, "$($ModuleName).Attributes.ps1")
            $cleanContents = (($attributesUsingStatements | ForEach-Object { $_.Trim() }) | Sort-Object -Unique) -join "`n"
            if (-not (Test-Path $path)) {
                New-Item -Path $path -ItemType File
            }
            $currentContents = Get-Content $path -Raw
            $newContents = @($cleanContents, $currentContents)
            ($newContents -join "`n") | Set-Content $path -Encoding UTF8 -Force
        }
        { $classesUsingStatements.Count -ge 1 } {
            Write-BuildLog "[$ModuleName] Adding using statements to $($ModuleName).Classes.ps1"
            $path = [System.IO.Path]::Combine($TargetVersionDirectory, "$($ModuleName).Classes.ps1")
            $cleanContents = (($classesUsingStatements | ForEach-Object { $_.Trim() }) | Sort-Object -Unique) -join "`n"
            if (-not (Test-Path $path)) {
                New-Item -Path $path -ItemType File
            }
            $currentContents = Get-Content $path -Raw
            $newContents = @($cleanContents, $currentContents)
            ($newContents -join "`n") | Set-Content $path -Encoding UTF8 -Force
        }
    }
    if ($updatedScriptsToProcess.Count) {
        Update-Metadata -Path $TargetManifestPath -PropertyName ScriptsToProcess -Value $updatedScriptsToProcess
    }
}

Task ImportCore -If {Test-Path $TargetManifestPath} Init, {
    Write-BuildLog "Testing import of VaporShell"
    Import-Module "$BuildRoot/BuildOutput/VaporShell" -ErrorAction Stop -Force
}

Task ImportSubmodules -If {Test-Path "$BuildRoot/BuildOutput/VaporShell.Workspaces"} Init, {
    $mods = Get-ChildItem $TargetDirectory -Filter 'VaporShell*'
    $i = 0
    $mods | ForEach-Object {
        $i++
        Write-BuildLog "[$i/$($mods.Count)] Testing import of $($_.BaseName)"
        Import-Module $_.FullName -ErrorAction Stop -Force
    }
}

# Synopsis: Imports the newly compiled module
Task Import Init, ImportCore, ImportSubmodules

Task PesterBefore {
    if ($module = Get-Module $ModuleName) {
        Write-BuildLog "$ModuleName is currently imported. Removing module and cleaning up any leftover aliases"
        $module | Remove-Module -Force
        $aliases = @{ }
        $aliasPath = [System.IO.Path]::Combine($BuildRoot, $ModuleName, "$ModuleName.Aliases.ps1")
        if (Test-Path $aliasPath) {
            (. $aliasPath).Keys | ForEach-Object {
                if (Get-Alias "$_*") {
                    Remove-Alias -Name $_ -Force
                }
            }
        }
    }
    $testModules = @(
        @{
            Name           = 'Pester'
            MinimumVersion = '4.10.1'
            MaximumVersion = '4.99.99'
        }
        @{
            Name           = 'Assert'
            MinimumVersion = '0.9.5'
        }
    )
    foreach ($testModule in $testModules) {
        Write-BuildLog "[$($testModule.Name)] Resolving"
        try {
            if ($imported = Get-Module $($testModule.Name)) {
                Write-BuildLog "[$($testModule.Name)] Removing imported module"
                $imported | Remove-Module
            }
            Import-Module @testModule
        }
        catch {
            Write-BuildLog "[$($testModule.Name)] Installing missing module"
            Install-Module @testModule
            Import-Module @testModule
        }
    }
}

# Synopsis: Run Pester tests only (no Clean/Compile)
Task Test Init, PesterBefore, UnpackageBuildOutput, {
    Set-Location -PassThru $TargetModuleDirectory
    Get-Module $ModuleName | Remove-Module $ModuleName -ErrorAction SilentlyContinue -Verbose:$false
    Import-Module -Name $TargetModuleDirectory -Force -Verbose:$false
    $pesterPath = if ($null -eq $script:TestPath) {
        Join-Path $BuildRoot "Tests"
    }
    else {
        $script:TestPath
    }
    $pesterParams = @{
        OutputFormat = 'NUnitXml'
        OutputFile   = Join-Path $TargetDirectory "TestResults.xml"
        PassThru     = $true
        Path         = $pesterPath
    }
    Write-BuildLog 'Invoking Pester...'
    if ($global:ExcludeTag) {
        $pesterParams['ExcludeTag'] = $global:ExcludeTag
        Write-BuildLog "[PESTER] Excluding tag(s) [$($global:ExcludeTag -join ', ')]..."
    }
    if ($Script:Tag) {
        $pesterParams['Tag'] = $Script:Tag
        Write-BuildLog "[PESTER] Including tag(s) [$($Script:Tag -join ', ')]..."
    }
    Write-BuildLog 'Invoking Pester...'
    $testResults = Invoke-Pester @pesterParams
    Write-BuildLog 'Pester invocation complete!'
    if ($testResults.FailedCount -gt 0) {
        "`n~~~~~~~~~ FAILURES ~~~~~~~~~"
        $testResults.TestResult | Where-Object { -not $_.Passed } | Format-List
        Write-BuildError 'One or more Pester tests failed. Build cannot continue!'
    }
}

# Synopsis: Run PSScriptAnalyzer
Task Analyze Init, {
    $analysis = Invoke-ScriptAnalyzer -Path "$BuildRoot\$($env:BHProjectName)" -Recurse -Verbose:$false
    $errors = $analysis | Where-Object { $_.Severity -eq 'Error' }
    $warnings = $analysis | Where-Object { $_.Severity -eq 'Warning' }

    if (($errors.Count -eq 0) -and ($warnings.Count -eq 0)) {
        Write-BuildLog 'PSScriptAnalyzer passed without errors or warnings'
    }

    if (@($errors).Count -gt 0) {
        Write-Error -Message 'One or more Script Analyzer errors were found. Build cannot continue!'
        $errors | Format-Table
    }

    if (@($warnings).Count -gt 0) {
        Write-Warning -Message 'One or more Script Analyzer warnings were found. These should be corrected.'
        $warnings | Format-Table
    }
}

$psGalleryConditions = {
    -not [String]::IsNullOrEmpty($env:NugetApiKey) -and
    -not [String]::IsNullOrEmpty($NextModuleVersion) -and
    $env:BHBuildSystem -eq 'VSTS' -and
    (
        (($env:BHCommitMessage -match '!deploy' -or $env:BUILD_REASON -eq 'Schedule') -and $env:BHBranchName -in @('master','main')) -or
        $env:BHBranchName -match '^(beta|rc|nightly|alpha)$'
    )
}
$gitHubConditions = {
    -not [String]::IsNullOrEmpty($env:GitHubPAT) -and
    -not [String]::IsNullOrEmpty($NextModuleVersion) -and
    $env:BHBuildSystem -eq 'VSTS' -and ((
        ($env:BHCommitMessage -match '!deploy' -or $env:BUILD_REASON -eq 'Schedule') -and
        $env:BHBranchName -in @('master','main')
    ) -or (
        $env:BHCommitMessage -match '!github' -and $env:BHBranchName -eq "dev"
    ))
}
$tweetConditions = {
    -not [String]::IsNullOrEmpty($env:TwitterAccessSecret) -and
    -not [String]::IsNullOrEmpty($env:TwitterAccessToken) -and
    -not [String]::IsNullOrEmpty($env:TwitterConsumerKey) -and
    -not [String]::IsNullOrEmpty($env:TwitterConsumerSecret) -and
    -not [String]::IsNullOrEmpty($NextModuleVersion) -and
    $env:BHBuildSystem -eq 'VSTS' -and
    ($env:BHCommitMessage -match '!deploy' -or $env:BUILD_REASON -eq 'Schedule') -and
    $env:BHBranchName -in @('master','main')
}

Task PublishToPSGallery -If $psGalleryConditions {
    Write-BuildLog "Publishing VaporShell version [$($NextModuleVersion)] to PSGallery"
    $origModulePath = $env:PSModulePath
    $pathSeperator = [System.IO.Path]::PathSeparator
    if ( $env:PSModulePath.split($pathSeperator) -notcontains $Script:TargetDirectory ) {
        $env:PSModulePath = ($Script:TargetDirectory + $pathSeperator + $origModulePath)
    }
    Import-Module (Join-Path -Path $TargetVersionDirectory -ChildPath "VaporShell.psd1") -Force
    $pars = @{
        Path = $TargetVersionDirectory
        NuGetApiKey = $env:NugetApiKey
        Repository = 'PSGallery'
        Verbose = $true
    }
    Publish-Module @pars
    Get-ChildItem $SourceAdditionalModuleDirectory -Directory | ForEach-Object {
        Write-BuildLog "Publishing $($_.BaseName) version [$($NextModuleVersion)] to PSGallery"
        $subDirectory = [System.IO.Path]::Combine($TargetDirectory, $_.BaseName)
        $subVersionDirectory = Split-Path (Get-ChildItem $subDirectory -Recurse -Filter "$($_.BaseName).psd1")
        Write-BuildLog "Module found at: $subVersionDirectory"
        Import-Module (Join-Path -Path $subVersionDirectory -ChildPath "$($_.BaseName).psd1") -Force
        $pars = @{
            Path = $subVersionDirectory
            NuGetApiKey = $env:NugetApiKey
            Repository = 'PSGallery'
            Verbose = $true
        }
        Publish-Module @pars
    }
    Write-BuildLog "Deployment successful!"
}

Task PackageBuildOutputAsArtifact -If {Test-Path $TargetManifestPath} Init, {
    $zipPath = "$BuildRoot/BuildOutput/BuildOutputCompressed.zip"
    if ((Test-Path $zipPath)) {
        Remove-Item $zipPath -Force
    }
    Compress-Archive -Path "$BuildRoot/BuildOutput" -DestinationPath $zipPath -Force
    Write-BuildLog "Zip created: $zipPath"
}

Task CleanBuildOutput -If {$IsCI -or (Test-Path Env:\TF_BUILD)} Init, {
    Write-BuildLog "Cleaning out BuildOutput folder"
    Get-ChildItem "$BuildRoot/BuildOutput" | Where-Object {$_.Name -notin @('BuildOutputCompressed.zip','ReleaseZips')} | ForEach-Object {
        remove $_.FullName
    }
}

Task UnpackageBuildOutput -If {Test-Path "$BuildRoot/BuildOutput/BuildOutputCompressed.zip"} Init, {
    $zipPath = "$BuildRoot/BuildOutput/BuildOutputCompressed.zip"
    Write-BuildLog "Expanding archive."
    Expand-Archive -Path $zipPath -DestinationPath $BuildRoot -Force
    Write-BuildLog "Zip expanded: $zipPath"
}

Task BuildReleaseZips Init, {
    Write-BuildLog "Creating Release ZIPs..."
    $releaseZipPath = [System.IO.Path]::Combine($BuildRoot,'BuildOutput','ReleaseZips')
    if (-not (Test-Path $releaseZipPath)) {
        $null = New-Item $releaseZipPath -ItemType Directory -Force
    }
    $zipPaths = @(
        @{
            ZipPath    = [System.IO.Path]::Combine($releaseZipPath, "$($ModuleName).zip")
            SourcePath = $TargetModuleDirectory
        }
    )
    Get-ChildItem $SourceAdditionalModuleDirectory -Directory | ForEach-Object {
        $zipPaths += @{
            ZipPath    = [System.IO.Path]::Combine($releaseZipPath, "$($_.BaseName).zip")
            SourcePath = [System.IO.Path]::Combine($TargetDirectory, $_.BaseName)
        }
    }
    Add-Type -Assembly System.IO.Compression.FileSystem
    foreach ($zip in $zipPaths) {
        if (Test-Path $zip.ZipPath) {
            Remove-Item $zip.ZipPath -Force
        }
        [System.IO.Compression.ZipFile]::CreateFromDirectory($zip.SourcePath, $zip.ZipPath)
        Write-BuildLog "Zip created: $((Get-Item $zip.ZipPath).Name)"
    }
    $fullZipPath = [System.IO.Path]::Combine($releaseZipPath, "FULL_VaporShell.zip")
    Compress-Archive -Path (Get-ChildItem ./BuildOutput/ -Directory | Where-Object {$_.BaseName -match '^VaporShell'}).FullName -DestinationPath $fullZipPath -Verbose -Force
    Write-BuildLog "FULL Zip created: $fullZipPath"
}

Task PublishToGitHub -If $gitHubConditions BuildReleaseZips, {
    $commitId = git rev-parse --verify HEAD

    Write-BuildLog "Publishing Release v$($NextModuleVersion) @ commit Id [$($commitId)] to GitHub..."

    $ReleaseNotes = . .\ci\GitHubReleaseNotes.ps1 -ModuleName $ModuleName -ModuleVersion $NextModuleVersion

    $zipPath = Get-ChildItem ([System.IO.Path]::Combine($BuildRoot,'BuildOutput','ReleaseZips')) -Filter '*.zip' | Select-Object -ExpandProperty FullName

    $gitHubParams = @{
        VersionNumber    = $NextModuleVersion.ToString()
        CommitId         = $commitId
        ReleaseNotes     = $ReleaseNotes
        GitHubUsername   = 'SCRT-HQ'
        GitHubRepository = $ModuleName
        GitHubApiKey     = $env:GitHubPAT
        Draft            = $false
    }
    if ($null -ne $zipPath) {
        $gitHubParams['ArtifactPath'] = $zipPath
    }
    Publish-GitHubRelease @gitHubParams
    Write-BuildLog "Release creation successful!"
}

Task PublishToTwitter -If $tweetConditions {
    if ($null -eq (Get-Module PoshTwit -ListAvailable)) {
        Write-BuildLog "Installing PoshTwit module"
        Install-Module PoshTwit -Scope CurrentUser -SkipPublisherCheck -AllowClobber -Repository PSGallery -Force
    }
    Import-Module PoshTwit -Verbose:$false
    Write-BuildLog "Publishing tweet about new release..."
    $manifest = Import-PowerShellDataFile -Path $TargetManifestPath
    $text = "#$($ModuleName) v$($NextModuleVersion) is now available on the #PSGallery! https://www.powershellgallery.com/packages/$($ModuleName)/$NextModuleVersion #PowerShell"
    $manifest.PrivateData.PSData.Tags | ForEach-Object {
        $text += " #$($_)"
    }
    if ($text.Length -gt 280) {
        Write-BuildLog "Trimming [$($text.Length - 280)] extra characters from tweet text to get to 280 character limit..."
        $text = $text.Substring(0, 280)
    }
    Write-BuildLog "Tweet text: $text"
    $publishTweetSplat = @{
        Tweet          = $text
        ConsumerSecret = $env:TwitterConsumerSecret
        ConsumerKey    = $env:TwitterConsumerKey
        AccessToken    = $env:TwitterAccessToken
        AccessSecret   = $env:TwitterAccessSecret
    }
    Publish-Tweet @publishTweetSplat
    Write-BuildLog "Tweet successful!"
}

Task Deploy Init, UnpackageBuildOutput, PublishToPSGallery, PublishToTwitter, PublishToGitHub
